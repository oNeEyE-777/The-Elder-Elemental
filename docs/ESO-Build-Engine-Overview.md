# ESO Build Engine Overview & Non-Negotiables

The ESO Build Engine is a data-driven system for representing ESO builds in a way that is stable, inspectable, and automatable. It separates ESO-specific content (skills, sets, CP, effects) from build configuration and from any UI, and it enforces strict rules about where data and logic live.[file:18][file:19][file:20]

At the core, this project starts with a single real build – **Permafrost Marshal** – but is designed so that the same data and logic structures can scale to a full ESO database without structural changes.[file:18][file:20]

## Canonical data files (current)

For the current v1 Data Center, the only canonical data JSON files are:

- `data/skills.json` – All skills used by builds, with metadata and effect references.[file:18]
- `data/effects.json` – All effects (buffs, debuffs, shields, HoTs, etc.) with math fields and stacking rules.[file:18][file:19]
- `data/sets.json` – All sets used by builds, with bonuses expressed as lists of effect IDs.[file:18]
- `data/cp-stars.json` – All CP stars used by builds, with tree, slot type, and effect IDs.[file:18]

These files are authoritative for ESO game data in this repo. Any additional data files (for example, future `mundus.json`, `food.json`, `enchants.json`) must be added explicitly to this list and documented in the v1 Data Model before being treated as canonical.[file:18][file:20]

Build records **never** duplicate ESO math or tooltips; they reference these data files by ID only.[file:18][file:19]

## Architecture layers

The ESO Build Engine is organized into three layers:[file:4][file:18][file:20]

1. **Data layer (JSON only)**
   - Canonical ESO-agnostic data lives under `data/`:
     - Skills, effects, sets, CP stars, and future data sources like Mundus stones or food.
   - Build definitions live under `builds/`:
     - Each build is a single JSON file that references IDs from `data/` and contains only numeric / structural configuration (bars, gear, CP layout, attributes, pillar targets).
   - No UI-specific or backend-specific fields are allowed in data JSON.

2. **Logic layer (Python tools under `tools/`)**
   - Stateless Python scripts that:
     - Validate data and builds (`validate_build.py`, `validate_build_test.py`).[file:19][file:20]
     - Aggregate effects (`aggregate_effects.py`).
     - Evaluate pillar requirements (`compute_pillars.py`).
     - Export Markdown summaries (`export_build_md.py`, `export_build_test_md.py`).
   - All ESO rules and math live here or in the data JSONs, never in ad-hoc scripts or the UI.

3. **Presentation/UI layer (backend + frontend, future)**
   - A Node/Express TypeScript backend that reads `data/` and `builds/` and exposes REST endpoints for data, validation, and computed outputs.[file:20] All backend routes are served under the `/api` base path (for example, `/api/health`, `/api/data/summary`, `/api/data`, `/api/builds/permafrost-marshal`).[web:300]
   - A React/Vite frontend that:
     - Uses selector-only inputs for skills, sets, CP (no free text).
     - Reads data and builds from the backend.
     - Displays computed effects and pillars.
   - No ESO game logic is duplicated in the UI; it uses the same JSON + Python tool outputs as the source of truth.

## Non-negotiable rules

These rules apply to all work on this repo:[file:4][file:18][file:19][file:20]

- **Git is the single source of truth.**
  - All data and logic must live in tracked files in this repository.
  - No external databases or hidden configuration.

- **Data/logic separation.**
  - ESO game data lives only in JSON under `data/`.
  - Builds live only in JSON under `builds/` and reference data IDs.
  - All math and validation logic lives in Python under `tools/`.
  - Backend and frontend consume JSON + Python outputs; they do not invent new rules.

- **Generated views are never edited by hand.**
  - Markdown build grids (e.g., `builds/permafrost-marshal.md`, `builds/test-dummy.md`) are generated by tools and must not be hand-edited.[file:20]

- **Full-file edits only.**
  - When changing a file, edits are made as complete file replacements (no partial patches), to simplify review and avoid drift.

- **Validation-first workflow.**
  - Any change to data or builds must be followed by running validators (e.g., `python tools/validate_build.py`) before commit.[file:19][file:20]
  - The `test-dummy` build is used first to ensure pipeline correctness before touching Permafrost Marshal.

- **Logic-driven terminology.**
  - Structured fields, enums, and function names must be logic-driven and ESO-agnostic:
    - Use terms like `resistance_flat`, `damage_taken_scalar`, `movement_speed_scalar`, `state_active`.[file:19]
    - Do **not** use ESO slang in structured data: no `Major Resolve`, `Major Breach`, `buffed`, `unbuffed` as enum values.
  - ESO-specific terms are allowed only in:
    - Human-facing `name` / `description` fields.
    - Opaque IDs such as `skill.deep_fissure`, `effect.buff.major_resolve`, `set.mark_of_the_pariah`.[file:19]

## Build scope and scaling

The initial scope is centered on one real build:[file:18][file:20]

- `builds/permafrost-marshal.json` – Permafrost Marshal build, fully wired to skills, sets, effects,
